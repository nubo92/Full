<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>이벤트 객체와 this</title>
</head>
<body>
<h1>이벤트 객체와 핸들러 내부의 this</h1>

<hr>

<h3>1. 이벤트 객체: 상세한 '사건 보고서'</h3>
<pre>
    이벤트가 발생하면, 브라우저는 해당 이벤트의 모든 정보가 담긴 '이벤트 객체'를 생성합니다.
    이 객체는 이벤트 핸들러(우리가 등록한 함수)의 <b>첫 번째 인자</b>로 자동으로 전달됩니다.
    </pre>

<h2 id="msg">여기를 클릭하면, 클릭한 곳의 마우스 좌표를 알려드립니다.</h2>

<script>
    const $msg = document.getElementById('msg');

    // 핸들러 함수의 첫 번째 매개변수 (이름은 e, event 등 자유롭게)로 이벤트 객체를 받는다.
    document.addEventListener('click', (e) => {
        // 이벤트 객체에는 많은 정보가 담겨있다.
        // console.log(e);

        $msg.textContent = `마우스 좌표 -> X: ${e.clientX}, Y: ${e.clientY}`;

        // event.target: '실제로' 이벤트가 시작된 가장 깊은 곳은 요소 (중요!)
        // console.log('실제 클릭 대상 (event.target)', e.target);
    });
</script>

<hr>

<h3>2. 핸들러 내부의 `this`: '사건 당사자'는 누구인가?</h3>
<pre>
    `this`는 '누가 이 함수를 호출했는가'에 따라 가리키는 대상이 달라져서 혼란을 줄 수 있습니다.
    특히 화살표 함수를 쓸 때 주의해야 합니다.
    </pre>

<button id="btn">클릭해보세요</button>

<script>
    const $btn = document.getElementById('btn');

    // 1. 일반 function 함수 사용 시
    $btn.addEventListener('click', function(e) {
        // 이벤트를 부착한 요소($btn)를 가리킨다
        console.log('this', this);
        // e.currentTarget: 이벤트 리스너가 걸려 있는 요소
        console.log('e.currentTarget,', e.currentTarget);

        this.style.backgroundColor = 'green';
    });

    // 2. 화살표 함수 사용 시
    $btn.addEventListener('mouseover', (e) => {
        // 화살표 함수는 자신만의 'this'를 가지지 않기 때문에, 바깥 스코프를 가리킨다.
        console.log('this', this);

        console.log('e.currentTarget,', e.currentTarget);
    });
</script>

<hr>

<h3>3. 결론: `this` 대신 `e.currentTarget`을 사용하자!</h3>
<pre>
    `function`과 화살표 함수 사이에서 `this`가 다르게 동작하여 생기는 혼란을 피하기 위해,
    현대적인 자바스크립트 개발에서는 일관성을 유지하는 것이 중요합니다.

    <b>e.currentTarget</b>은 어떤 종류의 함수를 쓰든, <b>항상 이벤트를 부착한 바로 그 요소</b>를 가리킵니다.
    따라서 `this` 대신 `e.currentTarget`을 사용하는 것이 버그를 줄이는 가장 좋은 습관입니다.
    </pre>

<button id="best-practice-btn">Best Practice</button>
<script>
    const $bestBtn = document.getElementById('best-practice-btn');

    $bestBtn.addEventListener('click', (e) => {
        // this를 쓰지 않고, e.currentTarget을 사용한다.
        const btn = e.currentTarget;

        btn.textContent = '클릭되었습니다!';
        btn.style.backgroundColor = 'skyblue';

        // 2초 뒤에 원래대로 복구
        setTimeout(() => {
            btn.textContent = 'Best Practice';
            btn.style.backgroundColor = '';
        }, 2000);
    });
</script>

</body>
</html>