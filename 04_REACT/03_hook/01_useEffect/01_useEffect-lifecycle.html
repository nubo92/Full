<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">

        const { useState, useEffect } = React;

        function Counter() {
            const [count, setCount] = useState(0);
            const [otherState, setOtherState] = useState(0);


            // 1. 의존성 배열 생략 : 매 렌더링마다 실행
            useEffect(() => {
               // 렌더링이 '완료된 후 실행된다.'     
                console.log('렌더링될 때마다 실행');
                document.title = `너는 ${count}번 클릭했어!!`;
            });

            // 2. 빈 의존성 배열 [] : 첫 렌더링(Mount) 시에만 실행
            // 주로 초기 데이터 로딩(API 호출) 등에 사용된다.
            useEffect(() => {
                console.log('컴포넌트가 처음 화면에 나타남(Mount)');
            }, []);

            // 3. 의존성 배열에 특정 값 지정 [count] :해당 값이 변경될 때만 실행
            // 가장 일반적인 사용법이다. 불필요한 재실행을 막아 성능을 최적화한다.
            useEffect (() => {
                console.log(`count값이 ${count}로 변경될 때만 useEffect가 실행 됩니다.`);
            }, [count]);

            console.log('Counter 컴포넌트가 렌더링 되었습니다.');

            return (
                <>
                    <h2>단순 카운트</h2>
                    <p>{ count }번 클릭했습니다.</p>
                    <button onClick={ () => setCount(count + 1)}>클릭</button>
                    <p>Other State: {otherState}</p>
                    <button onClick={ () => setOtherState(otherState + 1)}>클릭</button>
                </>
            )
        }

        function Timer() {

            useEffect(() => {
                console.log(`타이머가 시작 되었습니다.(Mount)`);

                const timerId = setInterval( () => {
                    console.log('... 1초 경과 ...');
                }, 1000);

                // Cleanup 함수: useEffect가 반환하는 함수이다.
                // 이 함수는 컴포넌트가 화면에서 사라지기 직전(Unmount)에 호출된다.
                return () => {
                    console.log('타이머를 정리합니다.(Unmount)');

                    clearInterval(timerId);         // 생성했던 타이머 제거
                }
            }, []);

            return (
                <h3>타이머가 동작 중입니다. (콘솔을 확인하세요~)</h3>
            )
        }

        function App() {
            const [showTimer, setShowTimer] = useState(true);

            return (
                <>
                    <Counter />
                    <hr />
                    <button onClick={ () => setShowTimer(!showTimer)}>
                        타이머 보이기/숨기기    
                    </button>

                    {/* showTimer가 true일 때만 Timer 컴포넌트가 렌더링 된다. */}
                    {showTimer && <Timer />}
                </>
            );
        }

        ReactDOM.createRoot(document.getElementById('root')).render(<App />);

    </script>
</body>
</html>